///
/// NitroBackgroundNotificationOptions.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `NitroBackgroundNotificationOptions`, backed by a C++ struct.
 */
public typealias NitroBackgroundNotificationOptions = margelo.nitro.nitrobackground.NitroBackgroundNotificationOptions

public extension NitroBackgroundNotificationOptions {
  private typealias bridge = margelo.nitro.nitrobackground.bridge.swift

  /**
   * Create a new instance of `NitroBackgroundNotificationOptions`.
   */
  init(taskTitle: String?, taskDesc: String?, taskIcon: TaskIconOptions?, color: String?, linkingURI: String?, progressBar: ProgressBarOptions?) {
    self.init({ () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = taskTitle {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = taskDesc {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_TaskIconOptions_ in
      if let __unwrappedValue = taskIcon {
        return bridge.create_std__optional_TaskIconOptions_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = color {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = linkingURI {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_ProgressBarOptions_ in
      if let __unwrappedValue = progressBar {
        return bridge.create_std__optional_ProgressBarOptions_(__unwrappedValue)
      } else {
        return .init()
      }
    }())
  }

  var taskTitle: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__taskTitle.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__taskTitle = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var taskDesc: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__taskDesc.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__taskDesc = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var taskIcon: TaskIconOptions? {
    @inline(__always)
    get {
      return { () -> TaskIconOptions? in
        if let __unwrapped = self.__taskIcon.value {
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__taskIcon = { () -> bridge.std__optional_TaskIconOptions_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_TaskIconOptions_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var color: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__color.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__color = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var linkingURI: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if let __unwrapped = self.__linkingURI.value {
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__linkingURI = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var progressBar: ProgressBarOptions? {
    @inline(__always)
    get {
      return { () -> ProgressBarOptions? in
        if let __unwrapped = self.__progressBar.value {
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__progressBar = { () -> bridge.std__optional_ProgressBarOptions_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_ProgressBarOptions_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
}
